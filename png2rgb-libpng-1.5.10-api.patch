*** png2rgb/png2rgb.c.~1.2.~	2008-04-12 14:08:55.000000000 -0300
--- png2rgb/png2rgb.c	2012-06-21 00:56:59.886075994 -0300
***************
*** 1,4 ****
--- 1,10 ----
  /* Copyright (c) 2007 Mega Man */
+ 
+ /* Changelog */
+ 
+ /* 2012-06-20  Bruno FÃ©lix Rezende Ribeiro  <oitofelix@gmail.com> */
+ /* Adapted to libpng 1.5.10 API */
+ 
  #include <png.h>
  #include <stdint.h>
  #include <malloc.h>
***************
*** 16,23 ****
  #endif
  
  /* Read a PNG file. */
! uint8_t *loadPng(const char *file_name, uint16_t * width, uint16_t * height,
! 	uint16_t * depth)
  
  /* We need to open the file */
  {
--- 22,29 ----
  #endif
  
  /* Read a PNG file. */
! uint8_t *loadPng(const char *file_name, png_uint_32 *width, png_uint_32 *height,
! 	int *depth)
  
  /* We need to open the file */
  {
***************
*** 27,32 ****
--- 33,39 ----
  	FILE *fp;
  	int x, y;
  	uint8_t *dest;
+ 	int color_type, bit_depth;
  
  	if ((fp = fopen(file_name, "rb")) == NULL)
  		return NULL;
***************
*** 45,51 ****
  	info_ptr = png_create_info_struct(png_ptr);
  	if (info_ptr == NULL) {
  		fclose(fp);
! 		png_destroy_read_struct(&png_ptr, png_infopp_NULL, png_infopp_NULL);
  		return NULL;
  	}
  
--- 52,58 ----
  	info_ptr = png_create_info_struct(png_ptr);
  	if (info_ptr == NULL) {
  		fclose(fp);
! 		png_destroy_read_struct(&png_ptr, (png_infopp)NULL, (png_infopp)NULL);
  		return NULL;
  	}
  
***************
*** 54,60 ****
  	 */
  	if (setjmp(png_jmpbuf(png_ptr))) {
  		/* Free all of the memory associated with the png_ptr and info_ptr */
! 		png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);
  		fclose(fp);
  		/* If we get here, we had a problem reading the file */
  		return NULL;
--- 61,67 ----
  	 */
  	if (setjmp(png_jmpbuf(png_ptr))) {
  		/* Free all of the memory associated with the png_ptr and info_ptr */
!                 png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
  		fclose(fp);
  		/* If we get here, we had a problem reading the file */
  		return NULL;
***************
*** 69,97 ****
  	/* Read entire image. */
  	/* XXX: Assuming host is litle endian system like ps2 or x86. */
  	png_read_png(png_ptr, info_ptr,
! 		PNG_TRANSFORM_SWAP_ENDIAN /* png_transforms */ , png_voidp_NULL);
  
  	/* At this point you have read the entire image */
! 	printf("Width: %d Height: %d Depth: %d\n", (int) info_ptr->width,
! 		(int) info_ptr->height, (int) (info_ptr->pixel_depth / 8));
  
! 	*width = info_ptr->width;
! 	*height = info_ptr->height;
! 	*depth = info_ptr->pixel_depth / 8;
! 	if (info_ptr->color_type == PNG_COLOR_TYPE_RGBA) {
! 		if (info_ptr->pixel_depth != 32) {
! 			fprintf(stderr, "Color depth wrong %d (32 required).\n", info_ptr->pixel_depth);
  
  			/* clean up after the read, and free any memory allocated - REQUIRED */
! 			png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);
  			return NULL;
  		}
  	} else {
! 		if (info_ptr->pixel_depth != 24) {
! 			fprintf(stderr, "Color depth wrong %d (24 required).\n", info_ptr->pixel_depth);
  
  			/* clean up after the read, and free any memory allocated - REQUIRED */
! 			png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);
  			return NULL;
  		}
  	}
--- 76,105 ----
  	/* Read entire image. */
  	/* XXX: Assuming host is litle endian system like ps2 or x86. */
  	png_read_png(png_ptr, info_ptr,
! 		PNG_TRANSFORM_SWAP_ENDIAN /* png_transforms */ , NULL);
! 
! 	png_get_IHDR(png_ptr, info_ptr, width, height, &bit_depth, &color_type,
! 		     NULL, NULL, NULL);
  
  	/* At this point you have read the entire image */
! 	printf("Width: %d Height: %d Depth: %d\n", (int) *width,
! 	       (int) *height, (int) bit_depth);
  
! 	*depth = bit_depth / 2;
! 	if (color_type == PNG_COLOR_TYPE_RGBA) {
! 	  if (bit_depth != 8) {
! 			fprintf(stderr, "Color depth wrong %d (8 required).\n", bit_depth);
  
  			/* clean up after the read, and free any memory allocated - REQUIRED */
! 			png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
  			return NULL;
  		}
  	} else {
! 	  if (bit_depth != 4) {
! 			fprintf(stderr, "Color depth wrong %d (4 required).\n", bit_depth);
  
  			/* clean up after the read, and free any memory allocated - REQUIRED */
! 			png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
  			return NULL;
  		}
  	}
***************
*** 99,118 ****
  	/* close the file */
  	fclose(fp);
  
! 	dest = malloc(info_ptr->width * info_ptr->height * *depth);
! 	memset(dest, 0, info_ptr->width * info_ptr->height * *depth);
  
  	if (dest != NULL) {
  		/* Copy picture into destination memory and fix alpha channel. */
! 		for (y = 0; y < info_ptr->height; y++) {
  			unsigned char *p;
  
! 			p = info_ptr->row_pointers[y];
! 			for (x = 0; x < info_ptr->width; x++) {
  				unsigned char alpha;
  				int pos;
  
! 				if (info_ptr->color_type == PNG_COLOR_TYPE_RGBA) {
  					/* Value range 0 .. 255 changed to range 0 .. 128. */
  					alpha = p[3] >> 1;
  					if (alpha != 0)
--- 107,127 ----
  	/* close the file */
  	fclose(fp);
  
! 	dest = malloc(*width * *height * bit_depth);
! 	memset(dest, 0, *width * *height * bit_depth);
  
  	if (dest != NULL) {
  		/* Copy picture into destination memory and fix alpha channel. */
! 		for (y = 0; y < *height; y++) {
  			unsigned char *p;
  
! 			png_bytepp row_pointers = png_get_rows(png_ptr, info_ptr);
! 			p = row_pointers[y];
! 			for (x = 0; x < *width; x++) {
  				unsigned char alpha;
  				int pos;
  
! 				if (color_type == PNG_COLOR_TYPE_RGBA) {
  					/* Value range 0 .. 255 changed to range 0 .. 128. */
  					alpha = p[3] >> 1;
  					if (alpha != 0)
***************
*** 122,133 ****
  				}
  				alpha = 0x80 - alpha;
  
! 				pos = *depth * (y * info_ptr->width + x);
  				/* XXX: Assuming host is litle endian system like ps2 or x86. */
  				dest[pos + 0] = p[0];
  				dest[pos + 1] = p[1];
  				dest[pos + 2] = p[2];
! 				if (info_ptr->color_type == PNG_COLOR_TYPE_RGBA) {
  					dest[pos + 3] = alpha;
  					p += 4;
  				} else {
--- 131,142 ----
  				}
  				alpha = 0x80 - alpha;
  
! 				pos = *depth * (y * *width + x);
  				/* XXX: Assuming host is litle endian system like ps2 or x86. */
  				dest[pos + 0] = p[0];
  				dest[pos + 1] = p[1];
  				dest[pos + 2] = p[2];
! 				if (color_type == PNG_COLOR_TYPE_RGBA) {
  					dest[pos + 3] = alpha;
  					p += 4;
  				} else {
***************
*** 138,144 ****
  	}
  
  	/* clean up after the read, and free any memory allocated - REQUIRED */
! 	png_destroy_read_struct(&png_ptr, &info_ptr, png_infopp_NULL);
  
  	/* that's it */
  	return dest;
--- 147,153 ----
  	}
  
  	/* clean up after the read, and free any memory allocated - REQUIRED */
! 	png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
  
  	/* that's it */
  	return dest;
***************
*** 150,158 ****
  	char *prefix = NULL;
  	int i;
  	uint8_t *buffer = NULL;
! 	uint16_t width = 0;
! 	uint16_t height = 0;
! 	uint16_t depth = 0;
  	int size;
  
  	if (argc != 5) {
--- 159,167 ----
  	char *prefix = NULL;
  	int i;
  	uint8_t *buffer = NULL;
! 	png_uint_32 width = 0;
! 	png_uint_32 height = 0;
! 	int depth = 0;
  	int size;
  
  	if (argc != 5) {
